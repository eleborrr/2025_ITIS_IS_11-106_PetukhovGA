Skip to main content This browser is no longer supported. Upgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support. Download Microsoft Edge More info about Internet Explorer and Microsoft Edge Table of contents Exit focus mode Read in English Add Table of contents Read in English Add Add to plan Edit Share via Facebook x.com LinkedIn Email Print Table of contents Create web APIs with ASP.NET Core Article06/01/2024 16 contributors Feedback ASP.NET Core supports creating web APIs using controllers or using minimal APIs. Controllers in a web API are classes that derive from ControllerBase. Controllers are activated and disposed on a per request basis. This article shows how to use controllers for handling web API requests. For information on creating web APIs without controllers, see Tutorial: Create a minimal API with ASP.NET Core. ControllerBase class A controller-based web API consists of one or more controller classes that derive from ControllerBase. The web API project template provides a starter controller: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Web API controllers should typically derive from ControllerBase rather from Controller. Controller derives from ControllerBase and adds support for views, so it's for handling web pages, not web API requests. If the same controller must support views and web APIs, derive from Controller. The ControllerBase class provides many properties and methods that are useful for handling HTTP requests. For example, CreatedAtAction returns a 201 status code: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } The following table contains examples of methods in ControllerBase. Method Notes BadRequest Returns 400 status code. NotFound Returns 404 status code. PhysicalFile Returns a file. TryUpdateModelAsync Invokes model binding. TryValidateModel Invokes model validation. For a list of all available methods and properties, see ControllerBase. Attributes The Microsoft.AspNetCore.Mvc namespace provides attributes that can be used to configure the behavior of web API controllers and action methods. The following example uses attributes to specify the supported HTTP action verb and any known HTTP status codes that could be returned: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } Here are some more examples of attributes that are available. Attribute Notes [Route] Specifies URL pattern for a controller or action. [Bind] Specifies prefix and properties to include for model binding. [HttpGet] Identifies an action that supports the HTTP GET action verb. [Consumes] Specifies data types that an action accepts. [Produces] Specifies data types that an action returns. For a list that includes the available attributes, see the Microsoft.AspNetCore.Mvc namespace. ApiController attribute The [ApiController] attribute can be applied to a controller class to enable the following opinionated, API-specific behaviors: Attribute routing requirement Automatic HTTP 400 responses Binding source parameter inference Multipart/form-data request inference Problem details for error status codes Attribute on specific controllers The [ApiController] attribute can be applied to specific controllers, as in the following example from the project template: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Attribute on multiple controllers One approach to using the attribute on more than one controller is to create a custom base controller class annotated with the [ApiController] attribute. The following example shows a custom base class and a controller that derives from it: [ApiController] public class MyControllerBase : ControllerBase { } [Produces(MediaTypeNames.Application.Json)] [Route("[controller]")] public class PetsController : MyControllerBase Attribute on an assembly The [ApiController] attribute can be applied to an assembly. When the [ApiController] attribute is applied to an assembly, all controllers in the assembly have the [ApiController] attribute applied. There's no way to opt out for individual controllers. Apply the assembly-level attribute to the Program.cs file: using Microsoft.AspNetCore.Mvc; [assembly: ApiController] var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Attribute routing requirement The [ApiController] attribute makes attribute routing a requirement. For example: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Actions are inaccessible via conventional routes defined by UseEndpoints, UseMvc, or UseMvcWithDefaultRoute. Automatic HTTP 400 responses The [ApiController] attribute makes model validation errors automatically trigger an HTTP 400 response. Consequently, the following code is unnecessary in an action method: if (!ModelState.IsValid) { return BadRequest(ModelState); } ASP.NET Core MVC uses the ModelStateInvalidFilter action filter to do the preceding check. Default BadRequest response The default response type for an HTTP 400 response is ValidationProblemDetails. The following response body is an example of the serialized type: { "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1", "title": "One or more validation errors occurred.", "status": 400, "traceId": "|7fb5e16a-4c8f23bbfc974667.", "errors": { "": [ "A non-empty request body is required." ] } } The ValidationProblemDetails type: Provides a machine-readable format for specifying errors in web API responses. Complies with the RFC 7807 specification. To make automatic and custom responses consistent, call the ValidationProblem method instead of BadRequest. ValidationProblem returns a ValidationProblemDetails object as well as the automatic response. Log automatic 400 responses To log automatic 400 responses, set the InvalidModelStateResponseFactory delegate property to perform custom processing. By default, InvalidModelStateResponseFactory uses ProblemDetailsFactory to create an instance of ValidationProblemDetails. The following example shows how to retrieve an instance of ILogger&lt;TCategoryName&gt; to log information about an automatic 400 response: var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { // To preserve the default behavior, capture the original delegate to call later. var builtInFactory = options.InvalidModelStateResponseFactory; options.InvalidModelStateResponseFactory = context =&gt; { var logger = context.HttpContext.RequestServices .GetRequiredService&lt;ILogger&lt;Program&gt;&gt;(); // Perform logging here. // ... // Invoke the default behavior, which produces a ValidationProblemDetails // response. // To produce a custom response, return a different implementation of // IActionResult instead. return builtInFactory(context); }; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Disable automatic 400 response To disable the automatic 400 behavior, set the SuppressModelStateInvalidFilter property to true. Add the following highlighted code: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Binding source parameter inference A binding source attribute defines the location at which an action parameter's value is found. The following binding source attributes exist: Attribute Binding source [FromBody] Request body [FromForm] Form data in the request body [FromHeader] Request header [FromQuery] Request query string parameter [FromRoute] Route data from the current request [FromServices] The request service injected as an action parameter [AsParameters] Method parameters Warning Don't use [FromRoute] when values might contain %2f (that is /). %2f won't be unescaped to /. Use [FromQuery] if the value might contain %2f. Without the [ApiController] attribute or binding source attributes like [FromQuery], the ASP.NET Core runtime attempts to use the complex object model binder. The complex object model binder pulls data from value providers in a defined order. In the following example, the [FromQuery] attribute indicates that the discontinuedOnly parameter value is provided in the request URL's query string: [HttpGet] public ActionResult&lt;List&lt;Product&gt;&gt; Get( [FromQuery] bool discontinuedOnly = false) { List&lt;Product&gt; products = null; if (discontinuedOnly) { products = _productsInMemoryStore.Where(p =&gt; p.IsDiscontinued).ToList(); } else { products = _productsInMemoryStore; } return products; } The [ApiController] attribute applies inference rules for the default data sources of action parameters. These rules save you from having to identify binding sources manually by applying attributes to the action parameters. The binding source inference rules behave as follows: [FromServices] is inferred for complex type parameters registered in the DI Container. [FromBody] is inferred for complex type parameters not registered in the DI Container. An exception to the [FromBody] inference rule is any complex, built-in type with a special meaning, such as IFormCollection and CancellationToken. The binding source inference code ignores those special types. [FromForm] is inferred for action parameters of type IFormFile and IFormFileCollection. It's not inferred for any simple or user-defined types. [FromRoute] is inferred for any action parameter name matching a parameter in the route template. When more than one route matches an action parameter, any route value is considered [FromRoute]. [FromQuery] is inferred for any other action parameters. FromBody inference notes [FromBody] isn't inferred for simple types such as string or int. Therefore, the [FromBody] attribute should be used for simple types when that functionality is needed. When an action has more than one parameter bound from the request body, an exception is thrown. For example, all of the following action method signatures cause an exception: [FromBody] inferred on both because they're complex types. [HttpPost] public IActionResult Action1(Product product, Order order) [FromBody] attribute on one, inferred on the other because it's a complex type. [HttpPost] public IActionResult Action2(Product product, [FromBody] Order order) [FromBody] attribute on both. [HttpPost] public IActionResult Action3([FromBody] Product product, [FromBody] Order order) FromServices inference notes Parameter binding binds parameters through dependency injection when the type is configured as a service. This means it's not required to explicitly apply the [FromServices] attribute to a parameter. In the following code, both actions return the time: [Route("[controller]")] [ApiController] public class MyController : ControllerBase { public ActionResult GetWithAttribute([FromServices] IDateTime dateTime) =&gt; Ok(dateTime.Now); [Route("noAttribute")] public ActionResult Get(IDateTime dateTime) =&gt; Ok(dateTime.Now); } In rare cases, automatic DI can break apps that have a type in DI that is also accepted in an API controller's action methods. It's not common to have a type in DI and as an argument in an API controller action. To disable [FromServices] inference for a single action parameter, apply the desired binding source attribute to the parameter. For example, apply the [FromBody] attribute to an action parameter that should be bound from the body of the request. To disable [FromServices] inference globally, set DisableImplicitFromServicesParameters to true: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); builder.Services.AddSingleton&lt;IDateTime, SystemDateTime&gt;(); builder.Services.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; { options.DisableImplicitFromServicesParameters = true; }); var app = builder.Build(); app.MapControllers(); app.Run(); Types are checked at app startup with IServiceProviderIsService to determine if an argument in an API controller action comes from DI or from the other sources. The mechanism to infer binding source of API Controller action parameters uses the following rules: A previously specified BindingInfo.BindingSource is never overwritten. A complex type parameter, registered in the DI container, is assigned BindingSource.Services. A complex type parameter, not registered in the DI container, is assigned BindingSource.Body. A parameter with a name that appears as a route value in any route template is assigned BindingSource.Path. All other parameters are BindingSource.Query. Disable inference rules To disable binding source inference, set SuppressInferBindingSourcesForParameters to true: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; options.DisableImplicitFromServicesParameters = true; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Multipart/form-data request inference The [ApiController] attribute applies an inference rule for action parameters of type IFormFile and IFormFileCollection. The multipart/form-data request content type is inferred for these types. To disable the default behavior, set the SuppressConsumesConstraintForFormFileParameters property to true: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Problem details for error status codes MVC transforms an error result (a result with status code 400 or higher) to a result with ProblemDetails. The ProblemDetails type is based on the RFC 7807 specification for providing machine-readable error details in an HTTP response. Consider the following code in a controller action: if (pet == null) { return NotFound(); } The NotFound method produces an HTTP 404 status code with a ProblemDetails body. For example: { type: "https://tools.ietf.org/html/rfc7231#section-6.5.4", title: "Not Found", status: 404, traceId: "0HLHLV31KRN83:00000001" } Disable ProblemDetails response The automatic creation of a ProblemDetails for error status codes is disabled when the SuppressMapClientErrors property is set to true. Add the following code: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Define supported request content types with the [Consumes] attribute By default, an action supports all available request content types. For example, if an app is configured to support both JSON and XML input formatters, an action supports multiple content types, including application/json and application/xml. The [Consumes] attribute allows an action to limit the supported request content types. Apply the [Consumes] attribute to an action or controller, specifying one or more content types: [HttpPost] [Consumes("application/xml")] public IActionResult CreateProduct(Product product) In the preceding code, the CreateProduct action specifies the content type application/xml. Requests routed to this action must specify a Content-Type header of application/xml. Requests that don't specify a Content-Type header of application/xml result in a 415 Unsupported Media Type response. The [Consumes] attribute also allows an action to influence its selection based on an incoming request's content type by applying a type constraint. Consider the following example: [ApiController] [Route("api/[controller]")] public class ConsumesController : ControllerBase { [HttpPost] [Consumes("application/json")] public IActionResult PostJson(IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/json", Values = values }); [HttpPost] [Consumes("application/x-www-form-urlencoded")] public IActionResult PostForm([FromForm] IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/x-www-form-urlencoded", Values = values }); } In the preceding code, ConsumesController is configured to handle requests sent to the https://localhost:5001/api/Consumes URL. Both of the controller's actions, PostJson and PostForm, handle POST requests with the same URL. Without the [Consumes] attribute applying a type constraint, an ambiguous match exception is thrown. The [Consumes] attribute is applied to both actions. The PostJson action handles requests sent with a Content-Type header of application/json. The PostForm action handles requests sent with a Content-Type header of application/x-www-form-urlencoded. Additional resources View or download sample code. (How to download). Controller action return types in ASP.NET Core web API Handle errors in ASP.NET Core controller-based web APIs Custom formatters in ASP.NET Core Web API Format response data in ASP.NET Core Web API ASP.NET Core web API documentation with Swagger / OpenAPI Routing to controller actions in ASP.NET Core Use port tunneling Visual Studio to debug web APIs Create a web API with ASP.NET Core ASP.NET Core supports creating web APIs using controllers or using minimal APIs. Controllers in a web API are classes that derive from ControllerBase. This article shows how to use controllers for handling web API requests. For information on creating web APIs without controllers, see Tutorial: Create a minimal API with ASP.NET Core. ControllerBase class A controller-based web API consists of one or more controller classes that derive from ControllerBase. The web API project template provides a starter controller: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Web API controllers should typically derive from ControllerBase rather from Controller. Controller derives from ControllerBase and adds support for views, so it's for handling web pages, not web API requests. If the same controller must support views and web APIs, derive from Controller. The ControllerBase class provides many properties and methods that are useful for handling HTTP requests. For example, CreatedAtAction returns a 201 status code: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } The following table contains examples of methods in ControllerBase. Method Notes BadRequest Returns 400 status code. NotFound Returns 404 status code. PhysicalFile Returns a file. TryUpdateModelAsync Invokes model binding. TryValidateModel Invokes model validation. For a list of all available methods and properties, see ControllerBase. Attributes The Microsoft.AspNetCore.Mvc namespace provides attributes that can be used to configure the behavior of web API controllers and action methods. The following example uses attributes to specify the supported HTTP action verb and any known HTTP status codes that could be returned: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } Here are some more examples of attributes that are available. Attribute Notes [Route] Specifies URL pattern for a controller or action. [Bind] Specifies prefix and properties to include for model binding. [HttpGet] Identifies an action that supports the HTTP GET action verb. [Consumes] Specifies data types that an action accepts. [Produces] Specifies data types that an action returns. For a list that includes the available attributes, see the Microsoft.AspNetCore.Mvc namespace. ApiController attribute The [ApiController] attribute can be applied to a controller class to enable the following opinionated, API-specific behaviors: Attribute routing requirement Automatic HTTP 400 responses Binding source parameter inference Multipart/form-data request inference Problem details for error status codes Attribute on specific controllers The [ApiController] attribute can be applied to specific controllers, as in the following example from the project template: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Attribute on multiple controllers One approach to using the attribute on more than one controller is to create a custom base controller class annotated with the [ApiController] attribute. The following example shows a custom base class and a controller that derives from it: [ApiController] public class MyControllerBase : ControllerBase { } [Produces(MediaTypeNames.Application.Json)] [Route("[controller]")] public class PetsController : MyControllerBase Attribute on an assembly The [ApiController] attribute can be applied to an assembly. When the [ApiController] attribute is applied to an assembly, all controllers in the assembly have the [ApiController] attribute applied. There's no way to opt out for individual controllers. Apply the assembly-level attribute to the Program.cs file: using Microsoft.AspNetCore.Mvc; [assembly: ApiController] var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Attribute routing requirement The [ApiController] attribute makes attribute routing a requirement. For example: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Actions are inaccessible via conventional routes defined by UseEndpoints, UseMvc, or UseMvcWithDefaultRoute. Automatic HTTP 400 responses The [ApiController] attribute makes model validation errors automatically trigger an HTTP 400 response. Consequently, the following code is unnecessary in an action method: if (!ModelState.IsValid) { return BadRequest(ModelState); } ASP.NET Core MVC uses the ModelStateInvalidFilter action filter to do the preceding check. Default BadRequest response The following response body is an example of the serialized type: { "": [ "A non-empty request body is required." ] } The default response type for an HTTP 400 response is ValidationProblemDetails. The following response body is an example of the serialized type: { "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1", "title": "One or more validation errors occurred.", "status": 400, "traceId": "|7fb5e16a-4c8f23bbfc974667.", "errors": { "": [ "A non-empty request body is required." ] } } The ValidationProblemDetails type: Provides a machine-readable format for specifying errors in web API responses. Complies with the RFC 7807 specification. To make automatic and custom responses consistent, call the ValidationProblem method instead of BadRequest. ValidationProblem returns a ValidationProblemDetails object as well as the automatic response. Log automatic 400 responses To log automatic 400 responses, set the InvalidModelStateResponseFactory delegate property to perform custom processing. By default, InvalidModelStateResponseFactory uses ProblemDetailsFactory to create an instance of ValidationProblemDetails. The following example shows how to retrieve an instance of ILogger&lt;TCategoryName&gt; to log information about an automatic 400 response: var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { // To preserve the default behavior, capture the original delegate to call later. var builtInFactory = options.InvalidModelStateResponseFactory; options.InvalidModelStateResponseFactory = context =&gt; { var logger = context.HttpContext.RequestServices .GetRequiredService&lt;ILogger&lt;Program&gt;&gt;(); // Perform logging here. // ... // Invoke the default behavior, which produces a ValidationProblemDetails // response. // To produce a custom response, return a different implementation of // IActionResult instead. return builtInFactory(context); }; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Disable automatic 400 response To disable the automatic 400 behavior, set the SuppressModelStateInvalidFilter property to true. Add the following highlighted code: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Binding source parameter inference A binding source attribute defines the location at which an action parameter's value is found. The following binding source attributes exist: Attribute Binding source [FromBody] Request body [FromForm] Form data in the request body [FromHeader] Request header [FromQuery] Request query string parameter [FromRoute] Route data from the current request [FromServices] The request service injected as an action parameter Warning Don't use [FromRoute] when values might contain %2f (that is /). %2f won't be unescaped to /. Use [FromQuery] if the value might contain %2f. Without the [ApiController] attribute or binding source attributes like [FromQuery], the ASP.NET Core runtime attempts to use the complex object model binder. The complex object model binder pulls data from value providers in a defined order. In the following example, the [FromQuery] attribute indicates that the discontinuedOnly parameter value is provided in the request URL's query string: [HttpGet] public ActionResult&lt;List&lt;Product&gt;&gt; Get( [FromQuery] bool discontinuedOnly = false) { List&lt;Product&gt; products = null; if (discontinuedOnly) { products = _productsInMemoryStore.Where(p =&gt; p.IsDiscontinued).ToList(); } else { products = _productsInMemoryStore; } return products; } The [ApiController] attribute applies inference rules for the default data sources of action parameters. These rules save you from having to identify binding sources manually by applying attributes to the action parameters. The binding source inference rules behave as follows: [FromBody] is inferred for complex type parameters not registered in the DI Container. An exception to the [FromBody] inference rule is any complex, built-in type with a special meaning, such as IFormCollection and CancellationToken. The binding source inference code ignores those special types. [FromForm] is inferred for action parameters of type IFormFile and IFormFileCollection. It's not inferred for any simple or user-defined types. [FromRoute] is inferred for any action parameter name matching a parameter in the route template. When more than one route matches an action parameter, any route value is considered [FromRoute]. [FromQuery] is inferred for any other action parameters. FromBody inference notes [FromBody] isn't inferred for simple types such as string or int. Therefore, the [FromBody] attribute should be used for simple types when that functionality is needed. When an action has more than one parameter bound from the request body, an exception is thrown. For example, all of the following action method signatures cause an exception: [FromBody] inferred on both because they're complex types. [HttpPost] public IActionResult Action1(Product product, Order order) [FromBody] attribute on one, inferred on the other because it's a complex type. [HttpPost] public IActionResult Action2(Product product, [FromBody] Order order) [FromBody] attribute on both. [HttpPost] public IActionResult Action3([FromBody] Product product, [FromBody] Order order) Disable inference rules To disable binding source inference, set SuppressInferBindingSourcesForParameters to true: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Multipart/form-data request inference The [ApiController] attribute applies an inference rule for action parameters of type IFormFile and IFormFileCollection. The multipart/form-data request content type is inferred for these types. To disable the default behavior, set the SuppressConsumesConstraintForFormFileParameters property to true: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Problem details for error status codes MVC transforms an error result (a result with status code 400 or higher) to a result with ProblemDetails. The ProblemDetails type is based on the RFC 7807 specification for providing machine-readable error details in an HTTP response. Consider the following code in a controller action: if (pet == null) { return NotFound(); } The NotFound method produces an HTTP 404 status code with a ProblemDetails body. For example: { type: "https://tools.ietf.org/html/rfc7231#section-6.5.4", title: "Not Found", status: 404, traceId: "0HLHLV31KRN83:00000001" } Disable ProblemDetails response The automatic creation of a ProblemDetails for error status codes is disabled when the SuppressMapClientErrors property is set to true: using Microsoft.AspNetCore.Mvc; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; }); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Define supported request content types with the [Consumes] attribute By default, an action supports all available request content types. For example, if an app is configured to support both JSON and XML input formatters, an action supports multiple content types, including application/json and application/xml. The [Consumes] attribute allows an action to limit the supported request content types. Apply the [Consumes] attribute to an action or controller, specifying one or more content types: [HttpPost] [Consumes("application/xml")] public IActionResult CreateProduct(Product product) In the preceding code, the CreateProduct action specifies the content type application/xml. Requests routed to this action must specify a Content-Type header of application/xml. Requests that don't specify a Content-Type header of application/xml result in a 415 Unsupported Media Type response. The [Consumes] attribute also allows an action to influence its selection based on an incoming request's content type by applying a type constraint. Consider the following example: [ApiController] [Route("api/[controller]")] public class ConsumesController : ControllerBase { [HttpPost] [Consumes("application/json")] public IActionResult PostJson(IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/json", Values = values }); [HttpPost] [Consumes("application/x-www-form-urlencoded")] public IActionResult PostForm([FromForm] IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/x-www-form-urlencoded", Values = values }); } In the preceding code, ConsumesController is configured to handle requests sent to the https://localhost:5001/api/Consumes URL. Both of the controller's actions, PostJson and PostForm, handle POST requests with the same URL. Without the [Consumes] attribute applying a type constraint, an ambiguous match exception is thrown. The [Consumes] attribute is applied to both actions. The PostJson action handles requests sent with a Content-Type header of application/json. The PostForm action handles requests sent with a Content-Type header of application/x-www-form-urlencoded. Additional resources View or download sample code. (How to download). Controller action return types in ASP.NET Core web API Handle errors in ASP.NET Core controller-based web APIs Custom formatters in ASP.NET Core Web API Format response data in ASP.NET Core Web API ASP.NET Core web API documentation with Swagger / OpenAPI Routing to controller actions in ASP.NET Core Use port tunneling Visual Studio to debug web APIs Create a web API with ASP.NET Core ASP.NET Core supports creating RESTful services, also known as web APIs, using C#. To handle requests, a web API uses controllers. Controllers in a web API are classes that derive from ControllerBase. This article shows how to use controllers for handling web API requests. View or download sample code. (How to download). ControllerBase class A web API consists of one or more controller classes that derive from ControllerBase. The web API project template provides a starter controller: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Don't create a web API controller by deriving from the Controller class. Controller derives from ControllerBase and adds support for views, so it's for handling web pages, not web API requests. There's an exception to this rule: if you plan to use the same controller for both views and web APIs, derive it from Controller. The ControllerBase class provides many properties and methods that are useful for handling HTTP requests. For example, ControllerBase.CreatedAtAction returns a 201 status code: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } Here are some more examples of methods that ControllerBase provides. Method Notes BadRequest Returns 400 status code. NotFound Returns 404 status code. PhysicalFile Returns a file. TryUpdateModelAsync Invokes model binding. TryValidateModel Invokes model validation. For a list of all available methods and properties, see ControllerBase. Attributes The Microsoft.AspNetCore.Mvc namespace provides attributes that can be used to configure the behavior of web API controllers and action methods. The following example uses attributes to specify the supported HTTP action verb and any known HTTP status codes that could be returned: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } Here are some more examples of attributes that are available. Attribute Notes [Route] Specifies URL pattern for a controller or action. [Bind] Specifies prefix and properties to include for model binding. [HttpGet] Identifies an action that supports the HTTP GET action verb. [Consumes] Specifies data types that an action accepts. [Produces] Specifies data types that an action returns. For a list that includes the available attributes, see the Microsoft.AspNetCore.Mvc namespace. ApiController attribute The [ApiController] attribute can be applied to a controller class to enable the following opinionated, API-specific behaviors: Attribute routing requirement Automatic HTTP 400 responses Binding source parameter inference Multipart/form-data request inference Problem details for error status codes Attribute on specific controllers The [ApiController] attribute can be applied to specific controllers, as in the following example from the project template: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Attribute on multiple controllers One approach to using the attribute on more than one controller is to create a custom base controller class annotated with the [ApiController] attribute. The following example shows a custom base class and a controller that derives from it: [ApiController] public class MyControllerBase : ControllerBase { } [Produces(MediaTypeNames.Application.Json)] [Route("[controller]")] public class PetsController : MyControllerBase Attribute on an assembly The [ApiController] attribute can be applied to an assembly. Annotation in this manner applies web API behavior to all controllers in the assembly. There's no way to opt out for individual controllers. Apply the assembly-level attribute to the namespace declaration surrounding the Startup class: [assembly: ApiController] namespace WebApiSample { public class Startup { ... } } Attribute routing requirement The [ApiController] attribute makes attribute routing a requirement. For example: [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase Actions are inaccessible via conventional routes defined by UseEndpoints, UseMvc, or UseMvcWithDefaultRoute in Startup.Configure. Automatic HTTP 400 responses The [ApiController] attribute makes model validation errors automatically trigger an HTTP 400 response. Consequently, the following code is unnecessary in an action method: if (!ModelState.IsValid) { return BadRequest(ModelState); } ASP.NET Core MVC uses the ModelStateInvalidFilter action filter to do the preceding check. Default BadRequest response The following request body is an example of the serialized type: { "": [ "A non-empty request body is required." ] } The default response type for an HTTP 400 response is ValidationProblemDetails. The following request body is an example of the serialized type: { "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1", "title": "One or more validation errors occurred.", "status": 400, "traceId": "|7fb5e16a-4c8f23bbfc974667.", "errors": { "": [ "A non-empty request body is required." ] } } The ValidationProblemDetails type: Provides a machine-readable format for specifying errors in web API responses. Complies with the RFC 7807 specification. To make automatic and custom responses consistent, call the ValidationProblem method instead of BadRequest. ValidationProblem returns a ValidationProblemDetails object as well as the automatic response. Log automatic 400 responses To log automatic 400 responses, set the InvalidModelStateResponseFactory delegate property to perform custom processing in Startup.ConfigureServices. By default, InvalidModelStateResponseFactory uses ProblemDetailsFactory to create an instance of ValidationProblemDetails. The following example shows how to retrieve an instance of ILogger&lt;TCategoryName&gt; to log information about an automatic 400 response: services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { // To preserve the default behavior, capture the original delegate to call later. var builtInFactory = options.InvalidModelStateResponseFactory; options.InvalidModelStateResponseFactory = context =&gt; { var logger = context.HttpContext.RequestServices.GetRequiredService&lt;ILogger&lt;Startup&gt;&gt;(); // Perform logging here. // ... // Invoke the default behavior, which produces a ValidationProblemDetails response. // To produce a custom response, return a different implementation of IActionResult instead. return builtInFactory(context); }; }); Disable automatic 400 response To disable the automatic 400 behavior, set the SuppressModelStateInvalidFilter property to true. Add the following highlighted code in Startup.ConfigureServices: services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; options.DisableImplicitFromServicesParameters = true; }); Binding source parameter inference A binding source attribute defines the location at which an action parameter's value is found. The following binding source attributes exist: Attribute Binding source [FromBody] Request body [FromForm] Form data in the request body [FromHeader] Request header [FromQuery] Request query string parameter [FromRoute] Route data from the current request [FromServices] The request service injected as an action parameter Warning Don't use [FromRoute] when values might contain %2f (that is /). %2f won't be unescaped to /. Use [FromQuery] if the value might contain %2f. Without the [ApiController] attribute or binding source attributes like [FromQuery], the ASP.NET Core runtime attempts to use the complex object model binder. The complex object model binder pulls data from value providers in a defined order. In the following example, the [FromQuery] attribute indicates that the discontinuedOnly parameter value is provided in the request URL's query string: [HttpGet] public ActionResult&lt;List&lt;Product&gt;&gt; Get( [FromQuery] bool discontinuedOnly = false) { List&lt;Product&gt; products = null; if (discontinuedOnly) { products = _productsInMemoryStore.Where(p =&gt; p.IsDiscontinued).ToList(); } else { products = _productsInMemoryStore; } return products; } The [ApiController] attribute applies inference rules for the default data sources of action parameters. These rules save you from having to identify binding sources manually by applying attributes to the action parameters. The binding source inference rules behave as follows: [FromBody] is inferred for complex type parameters. An exception to the [FromBody] inference rule is any complex, built-in type with a special meaning, such as IFormCollection and CancellationToken. The binding source inference code ignores those special types. [FromForm] is inferred for action parameters of type IFormFile and IFormFileCollection. It's not inferred for any simple or user-defined types. [FromRoute] is inferred for any action parameter name matching a parameter in the route template. When more than one route matches an action parameter, any route value is considered [FromRoute]. [FromQuery] is inferred for any other action parameters. FromBody inference notes [FromBody] isn't inferred for simple types such as string or int. Therefore, the [FromBody] attribute should be used for simple types when that functionality is needed. When an action has more than one parameter bound from the request body, an exception is thrown. For example, all of the following action method signatures cause an exception: [FromBody] inferred on both because they're complex types. [HttpPost] public IActionResult Action1(Product product, Order order) [FromBody] attribute on one, inferred on the other because it's a complex type. [HttpPost] public IActionResult Action2(Product product, [FromBody] Order order) [FromBody] attribute on both. [HttpPost] public IActionResult Action3([FromBody] Product product, [FromBody] Order order) Disable inference rules To disable binding source inference, set SuppressInferBindingSourcesForParameters to true. Add the following code in Startup.ConfigureServices: services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; options.DisableImplicitFromServicesParameters = true; }); Multipart/form-data request inference The [ApiController] attribute applies an inference rule for action parameters of type IFormFile and IFormFileCollection. The multipart/form-data request content type is inferred for these types. To disable the default behavior, set the SuppressConsumesConstraintForFormFileParameters property to true in Startup.ConfigureServices: services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; options.DisableImplicitFromServicesParameters = true; }); Problem details for error status codes MVC transforms an error result (a result with status code 400 or higher) to a result with ProblemDetails. The ProblemDetails type is based on the RFC 7807 specification for providing machine-readable error details in an HTTP response. Consider the following code in a controller action: if (pet == null) { return NotFound(); } The NotFound method produces an HTTP 404 status code with a ProblemDetails body. For example: { type: "https://tools.ietf.org/html/rfc7231#section-6.5.4", title: "Not Found", status: 404, traceId: "0HLHLV31KRN83:00000001" } Disable ProblemDetails response The automatic creation of a ProblemDetails for error status codes is disabled when the SuppressMapClientErrors property is set to true. Add the following code in Startup.ConfigureServices: services.AddControllers() .ConfigureApiBehaviorOptions(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; options.SuppressMapClientErrors = true; options.ClientErrorMapping[StatusCodes.Status404NotFound].Link = "https://httpstatuses.com/404"; options.DisableImplicitFromServicesParameters = true; }); Define supported request content types with the [Consumes] attribute By default, an action supports all available request content types. For example, if an app is configured to support both JSON and XML input formatters, an action supports multiple content types, including application/json and application/xml. The [Consumes] attribute allows an action to limit the supported request content types. Apply the [Consumes] attribute to an action or controller, specifying one or more content types: [HttpPost] [Consumes("application/xml")] public IActionResult CreateProduct(Product product) In the preceding code, the CreateProduct action specifies the content type application/xml. Requests routed to this action must specify a Content-Type header of application/xml. Requests that don't specify a Content-Type header of application/xml result in a 415 Unsupported Media Type response. The [Consumes] attribute also allows an action to influence its selection based on an incoming request's content type by applying a type constraint. Consider the following example: [ApiController] [Route("api/[controller]")] public class ConsumesController : ControllerBase { [HttpPost] [Consumes("application/json")] public IActionResult PostJson(IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/json", Values = values }); [HttpPost] [Consumes("application/x-www-form-urlencoded")] public IActionResult PostForm([FromForm] IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/x-www-form-urlencoded", Values = values }); } In the preceding code, ConsumesController is configured to handle requests sent to the https://localhost:5001/api/Consumes URL. Both of the controller's actions, PostJson and PostForm, handle POST requests with the same URL. Without the [Consumes] attribute applying a type constraint, an ambiguous match exception is thrown. The [Consumes] attribute is applied to both actions. The PostJson action handles requests sent with a Content-Type header of application/json. The PostForm action handles requests sent with a Content-Type header of application/x-www-form-urlencoded. Additional resources Controller action return types in ASP.NET Core web API Handle errors in ASP.NET Core controller-based web APIs Custom formatters in ASP.NET Core Web API Format response data in ASP.NET Core Web API ASP.NET Core web API documentation with Swagger / OpenAPI Routing to controller actions in ASP.NET Core Create a web API with ASP.NET Core [Route("api/[controller]")] [ApiController] public class ValuesController : ControllerBase Don't create a web API controller by deriving from the Controller class. Controller derives from ControllerBase and adds support for views, so it's for handling web pages, not web API requests. There's an exception to this rule: if you plan to use the same controller for both views and web APIs, derive it from Controller. The ControllerBase class provides many properties and methods that are useful for handling HTTP requests. For example, ControllerBase.CreatedAtAction returns a 201 status code: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } Here are some more examples of methods that ControllerBase provides: Method Notes BadRequest Returns 400 status code. NotFound Returns 404 status code. PhysicalFile Returns a file. TryUpdateModelAsync Invokes model binding. TryValidateModel Invokes model validation. For a list of all available methods and properties, see ControllerBase. Attributes The Microsoft.AspNetCore.Mvc namespace provides attributes that can be used to configure the behavior of web API controllers and action methods. The following example uses attributes to specify the supported HTTP action verb and any known HTTP status codes that could be returned: [HttpPost] [ProducesResponseType(StatusCodes.Status201Created)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public ActionResult&lt;Pet&gt; Create(Pet pet) { pet.Id = _petsInMemoryStore.Any() ? _petsInMemoryStore.Max(p =&gt; p.Id) + 1 : 1; _petsInMemoryStore.Add(pet); return CreatedAtAction(nameof(GetById), new { id = pet.Id }, pet); } Here are some more examples of attributes that are available: Attribute Notes [Route] Specifies URL pattern for a controller or action. [Bind] Specifies prefix and properties to include for model binding. [HttpGet] Identifies an action that supports the HTTP GET action verb. [Consumes] Specifies data types that an action accepts. [Produces] Specifies data types that an action returns. For a list that includes the available attributes, see the Microsoft.AspNetCore.Mvc namespace. ApiController attribute The [ApiController] attribute can be applied to a controller class to enable the following opinionated, API-specific behaviors: Attribute routing requirement Automatic HTTP 400 responses Binding source parameter inference Multipart/form-data request inference Problem details for error status codes The Problem details for error status codes feature requires a compatibility version of 2.2 or later. The other features require a compatibility version of 2.1 or later. Attribute routing requirement Automatic HTTP 400 responses Binding source parameter inference Multipart/form-data request inference These features require a compatibility version of 2.1 or later. Attribute on specific controllers The [ApiController] attribute can be applied to specific controllers, as in the following example from the project template: [Route("api/[controller]")] [ApiController] public class ValuesController : ControllerBase Attribute on multiple controllers One approach to using the attribute on more than one controller is to create a custom base controller class annotated with the [ApiController] attribute. The following example shows a custom base class and a controller that derives from it: [ApiController] public class MyControllerBase : ControllerBase { } [Produces(MediaTypeNames.Application.Json)] [Route("api/[controller]")] public class PetsController : MyControllerBase Attribute on an assembly If compatibility version is set to 2.2 or later, the [ApiController] attribute can be applied to an assembly. Annotation in this manner applies web API behavior to all controllers in the assembly. There's no way to opt out for individual controllers. Apply the assembly-level attribute to the namespace declaration surrounding the Startup class: [assembly: ApiController] namespace WebApiSample { public class Startup { ... } } Attribute routing requirement The [ApiController] attribute makes attribute routing a requirement. For example: [Route("api/[controller]")] [ApiController] public class ValuesController : ControllerBase Actions are inaccessible via conventional routes defined by UseMvc or UseMvcWithDefaultRoute in Startup.Configure. Automatic HTTP 400 responses The [ApiController] attribute makes model validation errors automatically trigger an HTTP 400 response. Consequently, the following code is unnecessary in an action method: if (!ModelState.IsValid) { return BadRequest(ModelState); } ASP.NET Core MVC uses the ModelStateInvalidFilter action filter to do the preceding check. Default BadRequest response With a compatibility version of 2.1, the default response type for an HTTP 400 response is SerializableError. The following request body is an example of the serialized type: { "": [ "A non-empty request body is required." ] } With a compatibility version of 2.2 or later, the default response type for an HTTP 400 response is ValidationProblemDetails. The following request body is an example of the serialized type: { "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1", "title": "One or more validation errors occurred.", "status": 400, "traceId": "|7fb5e16a-4c8f23bbfc974667.", "errors": { "": [ "A non-empty request body is required." ] } } The ValidationProblemDetails type: Provides a machine-readable format for specifying errors in web API responses. Complies with the RFC 7807 specification. To make automatic and custom responses consistent, call the ValidationProblem method instead of BadRequest. ValidationProblem returns a ValidationProblemDetails object as well as the automatic response. Log automatic 400 responses See How to log automatic 400 responses on model validation errors (dotnet/AspNetCore.Docs#12157). Disable automatic 400 response To disable the automatic 400 behavior, set the SuppressModelStateInvalidFilter property to true. Add the following highlighted code in Startup.ConfigureServices: services.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; }); Binding source parameter inference A binding source attribute defines the location at which an action parameter's value is found. The following binding source attributes exist: Attribute Binding source [FromBody] Request body [FromForm] Form data in the request body [FromHeader] Request header [FromQuery] Request query string parameter [FromRoute] Route data from the current request [FromServices] The request service injected as an action parameter Warning Don't use [FromRoute] when values might contain %2f (that is /). %2f won't be unescaped to /. Use [FromQuery] if the value might contain %2f. Without the [ApiController] attribute or binding source attributes like [FromQuery], the ASP.NET Core runtime attempts to use the complex object model binder. The complex object model binder pulls data from value providers in a defined order. In the following example, the [FromQuery] attribute indicates that the discontinuedOnly parameter value is provided in the request URL's query string: [HttpGet] public ActionResult&lt;List&lt;Product&gt;&gt; Get( [FromQuery] bool discontinuedOnly = false) { List&lt;Product&gt; products = null; if (discontinuedOnly) { products = _productsInMemoryStore.Where(p =&gt; p.IsDiscontinued).ToList(); } else { products = _productsInMemoryStore; } return products; } The [ApiController] attribute applies inference rules for the default data sources of action parameters. These rules save you from having to identify binding sources manually by applying attributes to the action parameters. The binding source inference rules behave as follows: [FromBody] is inferred for complex type parameters. An exception to the [FromBody] inference rule is any complex, built-in type with a special meaning, such as IFormCollection and CancellationToken. The binding source inference code ignores those special types. [FromForm] is inferred for action parameters of type IFormFile and IFormFileCollection. It's not inferred for any simple or user-defined types. [FromRoute] is inferred for any action parameter name matching a parameter in the route template. When more than one route matches an action parameter, any route value is considered [FromRoute]. [FromQuery] is inferred for any other action parameters. FromBody inference notes [FromBody] isn't inferred for simple types such as string or int. Therefore, the [FromBody] attribute should be used for simple types when that functionality is needed. When an action has more than one parameter bound from the request body, an exception is thrown. For example, all of the following action method signatures cause an exception: [FromBody] inferred on both because they're complex types. [HttpPost] public IActionResult Action1(Product product, Order order) [FromBody] attribute on one, inferred on the other because it's a complex type. [HttpPost] public IActionResult Action2(Product product, [FromBody] Order order) [FromBody] attribute on both. [HttpPost] public IActionResult Action3([FromBody] Product product, [FromBody] Order order) Note In ASP.NET Core 2.1, collection type parameters such as lists and arrays are incorrectly inferred as [FromQuery]. The [FromBody] attribute should be used for these parameters if they are to be bound from the request body. This behavior is corrected in ASP.NET Core 2.2 or later, where collection type parameters are inferred to be bound from the body by default. Disable inference rules To disable binding source inference, set SuppressInferBindingSourcesForParameters to true. Add the following code in Startup.ConfigureServices: services.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; }); Multipart/form-data request inference The [ApiController] attribute applies an inference rule for action parameters of type IFormFile and IFormFileCollection. The multipart/form-data request content type is inferred for these types. To disable the default behavior, set the SuppressConsumesConstraintForFormFileParameters property to true in Startup.ConfigureServices: services.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; { options.SuppressConsumesConstraintForFormFileParameters = true; options.SuppressInferBindingSourcesForParameters = true; options.SuppressModelStateInvalidFilter = true; }); Problem details for error status codes When the compatibility version is 2.2 or later, MVC transforms an error result (a result with status code 400 or higher) to a result with ProblemDetails. The ProblemDetails type is based on the RFC 7807 specification for providing machine-readable error details in an HTTP response. Consider the following code in a controller action: if (pet == null) { return NotFound(); } The NotFound method produces an HTTP 404 status code with a ProblemDetails body. For example: { type: "https://tools.ietf.org/html/rfc7231#section-6.5.4", title: "Not Found", status: 404, traceId: "0HLHLV31KRN83:00000001" } Disable ProblemDetails response The automatic creation of a ProblemDetails for error status codes is disabled when the SuppressMapClientErrors property is set to true. Add the following code in Startup.ConfigureServices: Define supported request content types with the [Consumes] attribute By default, an action supports all available request content types. For example, if an app is configured to support both JSON and XML input formatters, an action supports multiple content types, including application/json and application/xml. The [Consumes] attribute allows an action to limit the supported request content types. Apply the [Consumes] attribute to an action or controller, specifying one or more content types: [HttpPost] [Consumes("application/xml")] public IActionResult CreateProduct(Product product) In the preceding code, the CreateProduct action specifies the content type application/xml. Requests routed to this action must specify a Content-Type header of application/xml. Requests that don't specify a Content-Type header of application/xml result in a 415 Unsupported Media Type response. The [Consumes] attribute also allows an action to influence its selection based on an incoming request's content type by applying a type constraint. Consider the following example: [ApiController] [Route("api/[controller]")] public class ConsumesController : ControllerBase { [HttpPost] [Consumes("application/json")] public IActionResult PostJson(IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/json", Values = values }); [HttpPost] [Consumes("application/x-www-form-urlencoded")] public IActionResult PostForm([FromForm] IEnumerable&lt;int&gt; values) =&gt; Ok(new { Consumes = "application/x-www-form-urlencoded", Values = values }); } In the preceding code, ConsumesController is configured to handle requests sent to the https://localhost:5001/api/Consumes URL. Both of the controller's actions, PostJson and PostForm, handle POST requests with the same URL. Without the [Consumes] attribute applying a type constraint, an ambiguous match exception is thrown. The [Consumes] attribute is applied to both actions. The PostJson action handles requests sent with a Content-Type header of application/json. The PostForm action handles requests sent with a Content-Type header of application/x-www-form-urlencoded. Additional resources Controller action return types in ASP.NET Core web API Handle errors in ASP.NET Core controller-based web APIs Custom formatters in ASP.NET Core Web API Format response data in ASP.NET Core Web API ASP.NET Core web API documentation with Swagger / OpenAPI Routing to controller actions in ASP.NET Core Create a web API with ASP.NET Core Collaborate with us on GitHub The source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see our contributor guide. ASP.NET Core Open a documentation issue Provide product feedback Additional resources Additional resources